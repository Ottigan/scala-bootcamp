package com.evolutiongaming.bootcamp.testing2

import org.scalatest.funsuite.AnyFunSuite

// *Introduction*
//
// The bug which is not respresentable using the code will never happen.
// The simplest example of such defense is introduction of type system. I.e.
// if you have marked your field as `Integer` in your Java app, we do not need
// to test if it contains `String` inside. It simply cannot.
//
// Scala is much more powerful in that area, i.e., for example, we can make
// compile check if number is positive, if string is an actual e-mail etc. which
// is called refined types (https://github.com/fthomas/refined). We can also
// make sure the part of the code never accesses the database unless asked to do
// so etc., which is called effect tracking (https://typelevel.org/cats-effect/).
//
// It is not just a cool rocket science tech, we are using this stuff every day,
// and most Scala developers here won't be surprised if you ask them about it.
object PowerfulScala {

  // Excercise 1
  //
  // Prove Scala is at least as powerful as Java. Make sure that we cannot
  // call `energy("wrong stuff")`.
  //
  // Run the suite using the command below:
  //
  // sbt:scala-bootcamp> testOnly *testing2.PowerfulScalaSpec
  //
  def energy(mass: String): String = {
    val speedOfLight = BigDecimal(299792458)
    val energy = BigDecimal(mass) * speedOfLight.pow(2)
    energy.toString
  }

}
class PowerfulScalaSpec extends AnyFunSuite {

  test("we get a correct result") {
    assert(PowerfulScala.energy("100") == "8987551787368176400")
  }
  test("wrong call does not compile") {
    assertTypeError("""PowerfulScala.energy("wrong stuff")""")
  }

}
object Parametricity {

  // Excercise 2
  //
  // You, probably, heard about "parametric reasoning" previously during these
  // lectures. Let's repeat the material a bit again.
  //
  // There is a famous paper by Philop Walder called "Theorems for free!"
  //
  // Quote:
  // > Write down the definition of a polymorphic function on a piece of paper.
  // > Tell me its type, but be careful not to let me see the functionâ€™s
  // > definition. I will tell you a theorem that the function satisfies.
  //
  // Let's do some excersise to understand the concept (shamelessly stolen
  // from the article of Daniel Sebban)

  // Implement the following function in all possible ways:
  def f1_way1[A](a: A): A = ???
  def f1_way2[A](a: A): A = ???

  // Let's do another one...
  def f2_way1[A](a: A, b: A): A = ???
  def f2_way2[A](a: A, b: A): A = ???
  def f2_way3[A](a: A, b: A): A = ???

  // Can this function use `a` somehow in implementation?
  def f3[A](a: A, b: Int): Int = ???

  // How about this one?
  def f4[A](a: A, b: String): String = ???

  // Implement the following function in several ways:
  // What is common in all of these implementations?
  def f5_way1[A](as: List[A]): List[A] = ???
  def f5_way2[A](as: List[A]): List[A] = ???
  def f5_way3[A](as: List[A]): List[A] = ???

  // How many ways we can implement this function with?
  def f6[A, B](as: List[A]): List[B] = ???

  // How about this one?
  def f7[A](a: A): Int = ???

  // Excercise 3
  //
  // How can we use in real life besides creating puzzles for students?
  //
  // Less possibilities of implementations = less possibilties of bugs.
  // We only specify in types what we want to know adhering to so called
  // "Rule of least power".
  //
  // Try to break the functions below (so they return wrong results sometimes),
  // but stil pass the test. Run the tests like following:
  //
  // sbt:scala-bootcamp> testOnly *testing2.ParametricitySpec
  //
  def reversed1(list: List[Int]): List[Int] = list.reverse

  def reversed2[A](list: List[A]): List[A] = list.reverse

  def reversed3[T](list: T, reverse: T => T): T = reverse(list)

  // reversed3 does not look like real at all!
  // can we make it more convienient?
  //
  // yes, we can, can you break this function without breaking the test?

  def reversed4[T](list: T)(implicit reversable: Reversable[T]): T = reversable.reverse(list)

  // we neeed this boilerplate for this to work
  // often generated by libraries / macros:

  trait Reversable[T] { def reverse(a: T): T }
  implicit val listReversable: Reversable[List[Int]] = _.reverse

  // still, even if `Reversable` is implemented by library (JSON libraries love doing it)
  // it looks quite verbose, can we do less verbose?
  //
  // the approach is so popular tha there is a special syntax for it!

  def reversed5[T: Reversable](list: T): T = implicitly[Reversable[T]].reverse(list)

  // still too verbose?
  // libraries usually provide some more convinient methods of summoning it

  def reversed6[T: Reversable](list: T): T = Reversable[T].reverse(list)

  object Reversable {
    def apply[T](implicit reversable: Reversable[T]): Reversable[T] = reversable
  }

  // still unhappy?
  // they usually also provide a syntax
  def reversed7[T: Reversable](list: T): T = list.reverse

  implicit class ReversableSyntax[T](val self: T) extends AnyVal {
    def reverse(implicit reversable: Reversable[T]): T = reversable.reverse(self)
  }

  // do we need any tests for reversed3 - reversed7 at all?

}
class ParametricitySpec extends AnyFunSuite {

  test("reversed1 works correctly") {
    assert(Parametricity.reversed1(Nil) == Nil)
    assert(Parametricity.reversed1(List(1, 2, 3, 4, 5)) == List(5, 4, 3, 2, 1))
  }
  test("reversed2 works correctly") {
    assert(Parametricity.reversed2(Nil) == Nil)
    assert(Parametricity.reversed2(List(1, 2, 3, 4, 5)) == List(5, 4, 3, 2, 1))
  }
  test("reversed3 works correctly") {
    def reverse(list: List[Int]) = list.reverse
    assert(Parametricity.reversed3(List.empty[Int], reverse) == Nil)
    assert(Parametricity.reversed3(List(1, 2, 3, 4, 5), reverse) == List(5, 4, 3, 2, 1))
  }
  test("reversed4 works correctly") {
    assert(Parametricity.reversed4(List.empty[Int]) == Nil)
    assert(Parametricity.reversed4(List(1, 2, 3, 4, 5)) == List(5, 4, 3, 2, 1))
  }
  test("reversed5 works correctly") {
    assert(Parametricity.reversed5(List.empty[Int]) == Nil)
    assert(Parametricity.reversed5(List(1, 2, 3, 4, 5)) == List(5, 4, 3, 2, 1))
  }
  test("reversed6 works correctly") {
    assert(Parametricity.reversed6(List.empty[Int]) == Nil)
    assert(Parametricity.reversed6(List(1, 2, 3, 4, 5)) == List(5, 4, 3, 2, 1))
  }
  test("reversed7 works correctly") {
    assert(Parametricity.reversed7(List.empty[Int]) == Nil)
    assert(Parametricity.reversed7(List(1, 2, 3, 4, 5)) == List(5, 4, 3, 2, 1))
  }

}
